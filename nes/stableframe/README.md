# stableframe

An NES demo implementing supercat's [strategy for DMC-driven
IRQs](https://forums.nesdev.org/viewtopic.php?t=18854) by changing DMC frequency mid-interrupt.

<img width="480" alt="pre-sync"
src="https://user-images.githubusercontent.com/80639/176984613-bda3f15e-59ad-4c93-b988-0e26f7c8d458.png"> <img width="480" alt="post-sync" src="https://user-images.githubusercontent.com/80639/176984600-5b8c6e82-03a9-4b36-a878-b5b778cd297e.png">

This demo shows mid-frame IRQs to create 32 colored rows, each four scanlines apart, without using a mapper. It was tested in FCEUX, Mesen, and a front-loader NES (USA/NTSC).

## How it works

The NES doesn't provide a native timer capability to issue interrupts at different points in the
frame (to perform raster effects / update graphics mid-frame).
Usually you must resort to using a mapper to get this capability.

But, if your game is not using the
APU's DMC channel to play samples, you can manually synchronize this timer to the frame, and use the
DMC IRQ (when a sample is finished) as your mid-frame timer. supercat's strategy is to change the
DMC frequency mid-interrupt to allow for more precise timing, and also to keep triggering the DMC
sample fetch each interrupt, meaning the IRQ sequence never terminates.

The demo work the following:

1. When you load the game, DMC is disabled. NMI is also disabled (and unused).
2. When you press the A button, the game first tries to synchronize to a consistent PPU frame. (Copied from
   blargg's [full palette demo](https://www.nesdev.org/wiki/Full_palette_demo)) This may take a few
   blank frames to sync, presumably occurring right before starting a game level.
3. Next we synchronize the DMC timer. Because the timer delay could be at any point in the 54*8
   cycle sample period, we measure this delay and then change the DMC frequency four different times
   in the first interrupt to get it to a consistent spot.
4. At this point, the next IRQ that fires will happen at the start of scanline 241, during VBLANK.
   This serves the same purpose as NMI.
5. Each interrupt then does a lookup in the irq_routines_table (generated by a Python script) for
   the next interrupt logic. This points to different logic during the screen, such as changing the
   background color or modifying scroll.
6. At the end of the table there are four branches; because NTSC frames are 29780.5 cycles long, we
   need four frames with different offsets (+1.5 cycles, -0.5, -0.5, and -0.5) to make sure the
   frame is stable. This jitter is hidden in HBLANK.
7. The frame should now be stable. You can press B at any time to disable the IRQ chain and go back
   to #1.

And that's it. To customize this for your game, start with modifying `gen_irq_routines_table.py` and
build your custom routines in `irq_routines.asm`.

**NOTE:** The initial DMC synchronization may not be perfect, but it works consistently in my test
environment. When properly synchronized, IRQs seem to be consistent for at least several days running on my NES.

## References

* https://www.nesdev.org/wiki/APU_DMC#Usage_of_DMC_for_syncing_to_video
* ["DMC IRQs"](https://forums.nesdev.org/viewtopic.php?t=6521) on NESDev forums
* ["Efficient Technique for improving DMC timing
  accuracy"](https://forums.nesdev.org/viewtopic.php?t=18854) on NESDev forums
* blargg's [Full Palette Demo](https://www.nesdev.org/wiki/Full_palette_demo)
* https://github.com/bbbradsmith/6502vdelay

## License

MIT
