# stableframe

An NES demo implementing supercat's [strategy for DMC-driven
IRQs](https://forums.nesdev.org/viewtopic.php?t=18854) by changing DMC frequency mid-interrupt.

**Download the demo [stableframe.nes ðŸ•¹](https://github.com/tcr/8bit-demos/blob/main/nes/stableframe/stableframe.nes?raw=true)**

<img width="480" alt="pre-sync"
src="https://user-images.githubusercontent.com/80639/177176211-acc6d712-3894-44ef-8d40-87678eb5bb08.png"> <img width="480" alt="post-sync" src="https://user-images.githubusercontent.com/80639/177176290-5f335d98-1406-4479-b9db-430d25e3be53.png">

**This demo shows mid-frame IRQs to create 32 colored rows, each four scanlines apart, without using a
mapper. Each row modifies the color emphasis bits as well as scroll.** Instructions:

1. Press A to start mid-frame interrupts.
2. Press left and right buttons to shift the sync (for debugging).
3. Press B to reset the game.

This code should be able to be adapted for your game. It was motivated for use in the
[NESDev Compo 2022](https://itch.io/jam/nesdev-2022), as the "Games" category doesn't allow any
mappers that provide scanline-based IRQ support. The header does not specify a mapper (NROM). This
demo has been tested in FCEUX, Mesen, and a front-loader NES (USA/NTSC).

You may need to install the [AS Macroassembler](http://john.ccac.rwth-aachen.de:8000/as/) to build
via `make`.


## Theory

The NES doesn't provide a native timer capability to issue interrupts at different points in the
frame (to perform raster effects / update graphics mid-frame).
Usually you have to resort to using a mapper to get the capability to do per-scanline IRQs.

But if your game doesn't use the
[APU's DMC channel](https://www.nesdev.org/wiki/APU_DMC#Usage_of_DMC_for_syncing_to_video) to play
audio samples, you can manually synchronize
the DMC's timer to the frame, and use the DMC IRQ (when a sample is finished) as your mid-frame
timer.

A strategy suggested by [NESDev forum user supercat](https://forums.nesdev.org/viewtopic.php?t=18854) 
is to change the DMC frequency mid-interrupt to allow for more precise timing. Essentially, you
can influence when the DMC fires by using different combinations of DMCFREQ values during its 8-bit
sequence. If you can combine rates in a certain way, and modify DMCFREQ for any period of its 8
periods per sample (P0-P7), you can synchronize it with a particular CPU cycle. Thus, you can mostly
use DMC to trigger an interrupt exactly when you want.

The poster also suggests to keep triggering the DMC sample fetch each interruptâ€”meaning the IRQ
sequence never terminatesâ€”so that initial synchronization is only required once (presumably
occurring right before loading a game level). This is the approach used by this demo, since by only
synchronizing once, we can minimize the CPU cycles required to perform mid-frame interrupts.


## How it works

The demo works as follows:

1. When you load the game, DMC is disabled. NMI is also disabled (and unused).
2. When you press the A button, we enter `dmc_sync.asm`. Tthe game first tries to synchronize to a
   consistent PPU frame (with code copied from
   blargg's [full palette demo](https://www.nesdev.org/wiki/Full_palette_demo)). This may take a few
   blank frames to sync.
3. Next we synchronize the DMC timer. Because the timer could at this point be anywhere in its
   initial 54*8 cycle sample period, we measure this delay using a long series of `nop`s and the
   program counter.
4. Once the IRQ fires, we compensate for this measured delay, by changing the DMC frequency four
   times in a single interrupt to synchronize the timer to a consistent CPU cycle. This is done via
   a lookup table in `dmc_sync_table.asm` (generated by a Python script).
5. At this point, the next IRQ that fires will happen at the start of scanline 241, during VBLANK.
   This is the first entry in `irq_routines_table.asm` (generated by a Python
   script), and can serve the same purpose as NMI to perform writes to the PPU during VBLANK.
6. Each interrupt from now on executes one of the routines in `irq_routines.asm`. Some
   routines just set the next DMC cycle, but others can create visual effects such as changing the
   background color or modifying scroll.
7. At the end of the IRQ routines table we use four branches; because NTSC frames are 29780.5 cycles
   long, four frames with different offsets (+1.5 cycles, -0.5, -0.5, and -0.5) are needed to keep
   the number of cycles over time consistent. This introduces some jitter, which is hidden in
   HBLANK. (Note that the firing of an IRQ can be delayed by what's
   happening on the main loop; we stuff some 7-cycle opcodes in there to test worst case jitter.)
8. From now on, the frame should be stable. Code can execute on the main loop as well as via IRQ
   routines, including an IRQ routine timed to fire at the start of scaline 241 (VBLANK).
   You can press B at any time to desync and go back to step #1, to try different sync delays.

And that's it. To customize this for your game, start with modifying `gen_irq_routines_table.py` to
design one or multiple interrupt sequences, and build your custom routines in `irq_routines.asm` for
custom raster logic.

<img alt="mesen event viewer" src="https://user-images.githubusercontent.com/80639/177176442-e0fe0b49-ff84-44b9-9336-5c38d2f5e5f8.png">
<sub>Mesen Event Viewer showing IRQ, DMC, and PPU events in a synchronized frame.</sub>


## Console Screenshot

Photo of a front-loader (USA/NTSC) with an Everdrive. This TV is pretty small (5" diagonal?) but
shows a stable picture.
 
<img width="480" alt="physical"
src="https://user-images.githubusercontent.com/80639/176989947-abca9438-01b5-4fef-abe5-ee5aa3552aa6.png">


## Mesen Sync Stress Test Script

To stress test synchronization and learn more how it works, you have Mesen retry a bunch of
different `dmu_sync` "offset" values by randomly hitting the A, B, and reset buttons by loading
the `mesen_sync_stress_test.lua` script.

<img width="480" alt="image"
src="https://user-images.githubusercontent.com/80639/177175674-fddbdec4-e4c0-44ff-a001-f7b3149d077c.png">

The dialog will whenever DMC occurs. The offset should be any value from 0 to 54*8 (divided by two,
because the DMC clock is only ever a multiple of two, and the `nop` counter also can only measure
every two CPU cycles.) The script checks that the program ultimately fires its first post-sync IRQ
on scanline 240 with a PPU cycle of 338 or 339. This is followed by the demo executing the first CPU
instruction (the `jmp` trampoline stored in `zp_irq_jmp`) at the start of scanline 241.


## References

* https://www.nesdev.org/wiki/APU_DMC#Usage_of_DMC_for_syncing_to_video
* ["DMC IRQs"](https://forums.nesdev.org/viewtopic.php?t=6521) on NESDev forums
* ["Efficient Technique for improving DMC timing
  accuracy"](https://forums.nesdev.org/viewtopic.php?t=18854) on NESDev forums
* blargg's [Full Palette Demo](https://www.nesdev.org/wiki/Full_palette_demo)
* https://github.com/bbbradsmith/6502vdelay


## License

MIT
