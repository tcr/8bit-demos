# stableframe

An NES demo implementing supercat's [strategy for DMC-driven
IRQs](https://forums.nesdev.org/viewtopic.php?t=18854) by changing DMC frequency mid-interrupt.

**Download the demo [stableframe.nes ðŸ•¹](https://github.com/tcr/8bit-demos/blob/main/nes/stableframe/stableframe.nes?raw=true)**

<img width="480" alt="pre-sync"
src="https://user-images.githubusercontent.com/80639/176984613-bda3f15e-59ad-4c93-b988-0e26f7c8d458.png"> <img width="480" alt="post-sync" src="https://user-images.githubusercontent.com/80639/176984600-5b8c6e82-03a9-4b36-a878-b5b778cd297e.png">

This demo shows mid-frame IRQs to create 32 colored rows, each four scanlines apart, without using a
mapper. Each row modifies the color emphasis bits as well as scroll. This demo has been tested in
FCEUX, Mesen, and a front-loader NES (USA/NTSC).

This code should be able to be adapted for your game. It was motivated for use in the
[NESDev Compo 2022](https://itch.io/jam/nesdev-2022), as the "Games" category doesn't allow any
mappers that provide scanline-based IRQ support. The header does not specify a mapper (NROM).

You may need to install the [AS Macroassembler](http://john.ccac.rwth-aachen.de:8000/as/) to build
via `make`.


## How it works

The NES doesn't provide a native timer capability to issue interrupts at different points in the
frame (to perform raster effects / update graphics mid-frame).
Usually you have to resort to using a mapper to get the capability to do per-scanline IRQs.

But if your game doesn't use APU's DMC channel to play audio samples, you can manually synchronize
the DMC's timer to the frame, and use the DMC IRQ (when a sample is finished) as your mid-frame
timer.

A strategy suggested by [NESDev forum user supercat](https://forums.nesdev.org/viewtopic.php?t=18854) 
is to change the DMC frequency mid-interrupt to allow for more precise timing. They also suggest to
keep triggering the DMC sample fetch each interruptâ€”meaning the IRQ sequence never terminatesâ€”so
that initial synchronization is only required once (presumably occurring right before loading a game
level). By only synchronizing once, it also means that fewer CPU cycles are required to perform
mid-frame interrupts.

The demo works as follows:

1. When you load the game, DMC is disabled. NMI is also disabled (and unused).
2. When you press the A button, the game first tries to synchronize to a consistent PPU frame. (Copied from
   blargg's [full palette demo](https://www.nesdev.org/wiki/Full_palette_demo)) This may take a few
   blank frames to sync.
3. Next we synchronize the DMC timer. Because the timer delay could be at any point in the 54*8
   cycle sample period, we measure this delay using a long series of `nop`s and the program counter.
   Once the IRQ fires, we compensate for the delay we measured by change the DMC frequency four
   different times, synchronize the timer to a consistent CPU cycle.
4. At this point, the next IRQ that fires will happen at the start of scanline 241, during VBLANK.
   This is the first entry in `irq_routines_table`, and can serve the same purpose as NMI to perform
   writes to the PPU during VBLANK.
5. Each interrupt from now on does a lookup in the `irq_routines_table` (generated by a Python
   script) for interrupt logic. Some interrupts just set the next DMC cycle, but they can create
   visual effects such as changing the background color or modifying scroll.
6. At the end of the table there are four branches; because NTSC frames are 29780.5 cycles long, we
   need four frames with different offsets (+1.5 cycles, -0.5, -0.5, and -0.5) to make sure the
   frame is stable. This jitter is hidden in HBLANK. (Note that IRQ can be delayed by what's
   happening on the main loop; we stuff some 7-cycle opcodes in there to test worst case jitter.)
7. From now on, the frame should be stable. You can press B at any time to disable the IRQ chain
   and go back to step #1, to try different sync delays.

And that's it. To customize this for your game, start with modifying `gen_irq_routines_table.py` to
design your interrupt sequence, and build your custom routines in `irq_routines.asm` for custom
raster logic.

**NOTE:** The initial DMC synchronization may not be perfect. Rarely, bugs seem to appear during
repeated re-syncs in Mesen and FCEUX. Issues like these are fixable but hard to debug. But, when 
correctly synchronized, the frame seems to be stable for upwards of several days running on my NES.


## Mesen Script

To test how the synchronization works, you can see exactly which `dmu_sync` lookup value is used to
corresponds to DMC delay exactly when you press A by loading the `mesen_ppu_sync.lua` script.

<img width="480" alt="image"
src="https://user-images.githubusercontent.com/80639/176988384-8740181c-5242-4418-917e-632219235670.png">

The dialog will appear whenever you press A, and disappear when you press B to reset.


## References

* https://www.nesdev.org/wiki/APU_DMC#Usage_of_DMC_for_syncing_to_video
* ["DMC IRQs"](https://forums.nesdev.org/viewtopic.php?t=6521) on NESDev forums
* ["Efficient Technique for improving DMC timing
  accuracy"](https://forums.nesdev.org/viewtopic.php?t=18854) on NESDev forums
* blargg's [Full Palette Demo](https://www.nesdev.org/wiki/Full_palette_demo)
* https://github.com/bbbradsmith/6502vdelay


## License

MIT
