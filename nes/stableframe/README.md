# stableframe

An NES demo implementing supercat's [strategy for DMC-driven
IRQs](https://forums.nesdev.org/viewtopic.php?t=18854) by changing DMC frequency mid-interrupt.

**Download the demo [stableframe.nes ðŸ•¹](https://github.com/tcr/8bit-demos/blob/main/nes/stableframe/stableframe.nes?raw=true)**

<img width="480" alt="pre-sync"
src="https://user-images.githubusercontent.com/80639/176984613-bda3f15e-59ad-4c93-b988-0e26f7c8d458.png"> <img width="480" alt="post-sync" src="https://user-images.githubusercontent.com/80639/176984600-5b8c6e82-03a9-4b36-a878-b5b778cd297e.png">

This demo shows mid-frame IRQs to create 32 colored rows, each four scanlines apart, without using a
mapper. Each row modifies the color emphasis bits as well as scroll. This demo has been tested in
FCEUX, Mesen, and a front-loader NES (USA/NTSC).

This code should be able to be adapted for your game. It was motivated for use in the
[NESDev Compo 2022](https://itch.io/jam/nesdev-2022), as the "Games" category doesn't allow any
mappers that provide scanline-based IRQ support. The header does not specify a mapper (NROM).

You may need to install the [AS Macroassembler](http://john.ccac.rwth-aachen.de:8000/as/) to build
via `make`.


## Theory

The NES doesn't provide a native timer capability to issue interrupts at different points in the
frame (to perform raster effects / update graphics mid-frame).
Usually you have to resort to using a mapper to get the capability to do per-scanline IRQs.

But if your game doesn't use the
[APU's DMC channel](https://www.nesdev.org/wiki/APU_DMC#Usage_of_DMC_for_syncing_to_video) to play
audio samples, you can manually synchronize
the DMC's timer to the frame, and use the DMC IRQ (when a sample is finished) as your mid-frame
timer.

A strategy suggested by [NESDev forum user supercat](https://forums.nesdev.org/viewtopic.php?t=18854) 
is to change the DMC frequency mid-interrupt to allow for more precise timing. Essentially, you
can influence when the DMC fires by using different combinations of DMCFREQ values during its 8-bit
sequence. If you can combine rates in a certain way, and modify DMCFREQ for any period of its 8
periods per sample (P0-P7), you can synchronize it with a particular CPU cycle. Thus, you can mostly
use DMC to trigger an interrupt exactly when you want.

The poster also suggests to keep triggering the DMC sample fetch each interruptâ€”meaning the IRQ
sequence never terminatesâ€”so that initial synchronization is only required once (presumably
occurring right before loading a game level). This is the approach used by this demo, since by only
synchronizing once, we can minimize the CPU cycles required to perform mid-frame interrupts.


## How it works

The demo works as follows:

1. When you load the game, DMC is disabled. NMI is also disabled (and unused).
2. When you press the A button, the game first tries to synchronize to a consistent PPU frame. (Copied from
   blargg's [full palette demo](https://www.nesdev.org/wiki/Full_palette_demo)) This may take a few
   blank frames to sync. (NOTE: I am not an expert on this, but this seemed like a good idea for
   synchronizing the CPU and PPU together.)
3. Next we synchronize the DMC timer. Because the timer could at this point be anywhere in its
   initial 54*8 cycle sample period, we measure this delay using a long series of `nop`s and the
   program counter.
4. Once the IRQ fires, we compensate for this measured delay, by changing the DMC frequency four
   times in a single interrupt to synchronize the timer to a consistent CPU cycle. This is done via
   a lookup table in `dmc_sync.asm` (generated by a Python script).
5. At this point, the next IRQ that fires will happen at the start of scanline 241, during VBLANK.
   This is the first entry in `irq_routines_table.asm` (generated by a Python
   script), and can serve the same purpose as NMI to perform writes to the PPU during VBLANK.
6. Each interrupt from now on does a lookup in the `irq_routines_table` for interrupt logic. Some
   interrupts just set the next DMC cycle, but they can also create
   visual effects such as changing the background color or modifying scroll.
7. At the end of the table there are four branches; because NTSC frames are 29780.5 cycles long, we
   need four frames with different offsets (+1.5 cycles, -0.5, -0.5, and -0.5) to make sure the
   frame is stable. This jitter is hidden in HBLANK. (Note that IRQ can be delayed by what's
   happening on the main loop; we stuff some 7-cycle opcodes in there to test worst case jitter.)
8. From now on, the frame should be stable. You can press B at any time to disable the IRQ chain
   and go back to step #1, to try different sync delays.

And that's it. To customize this for your game, start with modifying `gen_irq_routines_table.py` to
design your interrupt sequence, and build your custom routines in `irq_routines.asm` for custom
raster logic.

**NOTE:** The initial DMC synchronization may not be perfect. Rarely, bugs seem to appear during
repeated re-syncs in Mesen and FCEUX. Issues like these are fixable but hard to debug. But, when 
correctly synchronized, the frame seems to be stable for upwards of several days running on my NES.


## Console Screenshot

Photo of a front-loader (USA/NTSC) with an Everdrive. This TV is pretty small (5" diagonal?) but
hopefully it showcases the demo well enough.
 
<img width="480" alt="physical"
src="https://user-images.githubusercontent.com/80639/176989947-abca9438-01b5-4fef-abe5-ee5aa3552aa6.png">


## Mesen Script

To test how the synchronization works, you can see exactly which `dmu_sync` "offset" is used when
you press A by loading the `mesen_ppu_sync.lua` script.

<img width="480" alt="image"
src="https://user-images.githubusercontent.com/80639/176988384-8740181c-5242-4418-917e-632219235670.png">

The dialog will appear whenever you press A, and disappear when you press B to reset. The
offset should be any value from 0 to 54*8 (divided by two, because the DMC clock is only ever a
multiple of two, and the `nop` counter also can only measure every two CPU cycles.). The program
should ultimately fire its first IRQ on scanline 240 with a PPU cycle of 338 or 339.
This should execute the first CPU instruction (the `jmp` command at `zp_irq_jmp`) at the start of
scanline 241.


## References

* https://www.nesdev.org/wiki/APU_DMC#Usage_of_DMC_for_syncing_to_video
* ["DMC IRQs"](https://forums.nesdev.org/viewtopic.php?t=6521) on NESDev forums
* ["Efficient Technique for improving DMC timing
  accuracy"](https://forums.nesdev.org/viewtopic.php?t=18854) on NESDev forums
* blargg's [Full Palette Demo](https://www.nesdev.org/wiki/Full_palette_demo)
* https://github.com/bbbradsmith/6502vdelay


## License

MIT
